## Dev code compilation
	gcc basic-tutorial-1.c -o basic-tutorial-1 `pkg-config --cflags --libs gstreamer-1.0`

## Initialize gstreamer 
  	gst_init (&argc, &argv);

## Build the pipeline 
	pipeline = gst_parse_launch("playbin, uri=...", NULL);

## Set element state
	ret = gst_element_set_state (pipeline, GST_STATE_PLAYING);

## retrieves the pipeline's bus
	bus = gst_element_get_bus (pipeline);

## gstreamer elements (particular kind of GObject)
	# Creation
	source = gst_element_factory_make ("videotestsrc", "source");

	"playin" - special element which acts as a source and as a sink, http://, file://
	"

## gstreamer pipeline

	# creation pipeline
	pipeline = gst_pipeline_new ("test-pipeline");
	
	# add elements to the pipeline
	gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);

	# link elements in the pipeline 
	gst_element_link (source, sink) != TRUE

## gstreamer pad

	GStreamer elements with their pads. ("GstPad") 
	The ports through which GStreamer elements communicate with each other are called pads. 

	# Handler for pad-added signal
	static void pad_added_handler (GstElement *src, GstPad *pad, CustomData *data);	
	g_signal_connect (data.source, "pad-added", G_CALLBACK (pad_added_handler), &data);

	# Callback 
	static void pad_added_handler (GstElement *src, GstPad *new_pad, CustomData *data)

	# check pad type
	new_pad_caps = gst_pad_get_current_caps (new_pad);

	# Pad templates
	SINK template: 'sink' SRC template: 'src' gst-inspect-1.0 vp8dec 
	pads = gst_element_factory_get_static_pad_templates (factory);
	pad = gst_element_get_static_pad (element, pad_name);
	caps = gst_pad_get_current_caps (pad);


## gstreamer multithreading
	
	This is accomplished using the queue element. The sink pad just enqueues data and returns control. 
    On a different thread, data is dequeued and pushed downstream. 

	GstElement *queue;
	audio_queue = gst_element_factory_make ("queue", "audio_queue");
	video_queue = gst_element_factory_make ("queue", "video_queue");
	
	inject data into a pipeline using the "appsrc" element.
	Retrieve data from a pipeline using the "appsink" element.
	Manipulate this data by accessing the "GstBuffer"	

## gstreamer gstreamer-pbutils-1.0 

	GstDiscoverer * discoverer
	gst_discoverer_info_get_uri()
	gst_discoverer_info_get_result()
	gst_discoverer_discover_uri_async()


## gstreamer bus 
	object responsible for delivering to the application the GstMessages generated by the elements.

    "gst_bus_timed_pop_filtered()" - extract messages 
	msg = gst_bus_timed_pop_filtered (bus, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);
	msg = gst_bus_timed_pop_filtered (bus, 100 * GST_MSECOND,...) 	# with 100 ms timeout

	# instruct the bus to emit a signal 
	gst_bus_add_signal_watch(...)

	# register function that gets called with a timeout 
	g_timeout_add_seconds(...) 
 
## Time management
	msg = gst_bus_timed_pop_filtered (bus, 100 * GST_MSECOND,...) 	# with 100 ms timeout
	gst_element_query_position (data.playbin, GST_FORMAT_TIME, &current)
	gst_element_query_duration (data.playbin, GST_FORMAT_TIME, &data.duration) 
		
## Cleanup
  gst_message_unref (msg);
  gst_object_unref (bus);
  gst_element_set_state (pipeline, GST_STATE_NULL);
  gst_object_unref (pipeline);	

## Build code
	gcc basic-tutorial-5.c -o basic-tutorial-5 `pkg-config --cflags --libs gtk+-3.0 gstreamer-1.0`
	gcc basic-tutorial-9.c -o basic-tutorial-9 `pkg-config --cflags --libs gstreamer-1.0 gstreamer-pbutils-1.0`
